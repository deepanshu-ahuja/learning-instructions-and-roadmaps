Goal:
Teach React from fundamental mental models to advanced rendering, performance, and system design,
ensuring even a weak beginner can understand deeply while preparing for senior-level interviews.

──────────────────────────────────────────────
LEVEL 0 — React Fundamentals & Core Mental Models

Topic 1 — Why React? Rendering Model & Declarative UI
    • What is UI = f(state)? (Beginner baseline)
    • Why declarative UI?
    • Virtual DOM (concept only)
    • Component tree
    • One-way data flow
    • Immutability basics
    • Imperative vs declarative comparison
    • Why React re-renders (baseline)

Topic 2 — JSX, Elements & Components
    • JSX vs HTML
    • Elements vs components
    • Component function vs component instance
    • Props, children, composition
    • Keys (early intro)
    • Clean component structure
    • How React converts JSX into elements
    • Render flow with simple examples

Topic 3 — State Basics & Re-Render Mechanics
    • What triggers a re-render
    • How React updates UI
    • Local vs derived state
    • Mutations vs immutability
    • Why parent renders cause child renders
    • Intro to referential equality
    • Visualizing re-renders
    • Basic render flow

──────────────────────────────────────────────
LEVEL 1 — Core Hooks & Data Flow

Topic 4 — useState Deep Dive
    • Where React stores state (order-based slots)
    • Primitive vs object state (value vs reference)
    • Functional updates (deep explanation)
    • Why functional updates fix stale values
    • Stale closures
    • Batching & synchronous updates
    • Why hooks cannot be in loops/conditions
    • Setter identity (setX never changes)
    • React does not merge object state

Topic 5 — useEffect Deep Dive
    • Render phase vs commit phase
    • When effects run & why
    • Dependency array mental model
    • Cleanup rules
    • Avoiding infinite loops
    • Why effects run after paint
    • Why effects run on every render
    • Common pitfalls (fetching, dependencies, stale closures)

Topic 6 — useRef & Persistent Values
    • DOM refs
    • Mutable container (current)
    • Avoiding unnecessary re-renders
    • Persistent values across renders
    • useRef vs state (when to use what)
    • Ref identity guarantees

Topic 7 — useMemo & useCallback
    • Memoization baseline (simple definition)
    • Preventing expensive recalculations
    • Preventing child re-renders
    • Referential equality rules
    • Overuse and incorrect cases
    • Dependency correctness
    • When memoization slows apps

Topic 8 — Context API (with performance rules)
    • Why Context exists
    • Provider → consumer flow
    • Value changes re-render all consumers
    • Splitting Context
    • Avoiding Context overuse
    • Alternatives (selectors, Zustand, Jotai — preview only)

──────────────────────────────────────────────
LEVEL 2 — Component Architecture & Real App Patterns

Topic 9 — Component Design Patterns
    • Container vs Presentational
    • Controlled vs uncontrolled
    • Compound components
    • Render props vs custom hooks
    • Slot pattern
    • Composition anti-patterns
    • Controlled vs uncontrolled performance differences
    • Architecture pitfalls

Topic 10 — Forms & Form Performance
    • Controlled vs uncontrolled
    • Why controlled re-renders on each keystroke
    • Validations
    • Performance-heavy form pitfalls
    • Why form libraries exist

Topic 11 — Routing (React Router)
    • Route-based rendering
    • Nested routes
    • Code-splitting with routes
    • Avoiding re-renders on navigation
    • Why route changes cause full render
    • Lazy boundaries & Suspense

Topic 12 — Local vs Global vs Server State
    • UI, global, and server state differences
    • When to lift state
    • Context vs Redux vs React Query
    • Decision framework
    • Rendering performance differences
    • Anti-patterns

Topic 13 — Custom Hooks (Full Deep Dive)
    • Why custom hooks exist
    • Sharing reusable logic
    • Parameterized hooks
    • Using internal ref, memo, effect
    • Avoiding stale closures
    • Hooks for fetching, forms, timers, resize/scroll, caching
    • Anti-patterns (conditional hooks, over-abstraction)
    • When NOT to write a custom hook

──────────────────────────────────────────────
LEVEL 3 — Redux & State Management Architecture

Topic 14 — Redux (Modern Redux Toolkit)
    • Store → reducer → state flow
    • Immer-based immutable updates
    • createSlice
    • createAsyncThunk
    • Avoiding boilerplate
    • When NOT to use Redux

Topic 15 — Scalable State Architecture
    • State colocation
    • Feature-based folder structure
    • Splitting slices
    • Global state design principles
    • Avoiding global-state overuse

Topic 16 — Server State (React Query / SWR)
    • Cached queries
    • staleTime, refetching
    • Over-fetching
    • Server-state vs client-state mental model
    • Background refetch
    • Mutation patterns

──────────────────────────────────────────────
LEVEL 4 — React Rendering Internals & Performance

Topic 17 — Reconciliation & Keys
    • How React diffs trees
    • Why keys matter
    • Key mismatches & bugs
    • Reconciliation performance impact
    • Why React re-renders children

Topic 18 — Render Behavior & Optimization
    • Parent-child render flow
    • Debugging unnecessary renders
    • React.memo deeply explained
    • Component splitting
    • Avoiding re-render storms

Topic 19 — Memoization in Real Apps
    • useMemo patterns
    • useCallback patterns
    • Dependency correctness
    • When memoization slows apps
    • Real performance examples

Topic 20 — Large Lists, Tables & Virtualization
    • Windowing concepts
    • react-window basics
    • Infinite scroll + virtualization
    • Dynamic row heights
    • Scroll restoration
    • Resize handling
    • Asset-heavy list optimization

Topic 21 — React 18 & Concurrency
    • Automatic batching
    • Concurrent rendering (concept)
    • useTransition
    • Suspense mental model
    • Urgent vs non-urgent updates
    • Interaction responsiveness

──────────────────────────────────────────────
LEVEL 5 — Frontend Performance (React + Web)

Topic 22 — Performance Measurement
    • React Profiler
    • Flame graphs
    • Interaction responsiveness
    • Identifying slow components
    • Scheduling impact

Topic 23 — Bundle Size Optimization
    • Tree-shaking
    • Code splitting
    • React.lazy + Suspense
    • Splitting heavy libs
    • Dynamic imports

Topic 24 — Network & Rendering Optimization
    • Minimizing API calls
    • Cache vs revalidate
    • Avoiding waterfalls
    • Image optimization
    • Skeletons vs spinners

Topic 25 — Core Web Vitals (React Perspective)
    • LCP, CLS, INP basics
    • Avoiding layout shifts
    • Patterns that hurt Web Vitals
    • Patterns that improve Web Vitals

──────────────────────────────────────────────
LEVEL 6 — Class Components (Interview-Focused)

Topic 26 — Class Components (Brief but Sufficient)
    • setState & lifecycle overview
    • Lifecycle timing
    • Comparison with hooks
    • Why hooks replaced classes

──────────────────────────────────────────────
LEVEL 7 — React 19 & Future-Proofing

Topic 27 — React 19 Features
    • Actions
    • Updated server components
    • Form actions
    • New hooks/features
    • Migration notes

──────────────────────────────────────────────
LEVEL 8 — React Interview & System Design

Topic 28 — React Theory Questions
    • Hooks rules
    • Rendering model
    • State management decisions
    • memo/useMemo/useCallback reasoning

Topic 29 — React Output-Based Questions
    • Hook order puzzles
    • useEffect timing
    • State batching
    • Stale closures
    • Render sequence questions

Topic 30 — React System Design Scenarios
    • Infinite scroll design
    • Dashboard design
    • List + filtering + debouncing
    • Global + local state architecture
    • Performance-first design

──────────────────────────────────────────────
LEVEL 9 — Optional Advanced Topics

Topic 31 — SSR & Hydration Basics (Light)
    • What SSR is (concept)
    • Hydration basics
    • Client vs server responsibilities
    • Not a Next.js deep dive

Topic 32 — Conceptual Rendering Pipeline
    • Render → commit cycle
    • Scheduling overview
    • Why React batches updates
    • Relationship to reconciliation
──────────────────────────────────────────────
